# 第一章：基础算法

本文内容主要来自acwing的算法课笔记，加入自己的理解或者自认为有用的其他来源。

## 一. 排序
#### 1.快速排序
**步骤**（对数组q[]）
1. 确定分界点：q[l],q[(l+r)/2],q[r]。最大最小中间值随机都可。
2. 调整区间：若分界点为x，将小于x的放在左边，大于x的放在右边（反过来同理，主要是一分为二）。
3. 递归处理左右两段。

**实现**
- 一种简单的方法：利用多余的空间![](https://s2.loli.net/2022/03/20/MVKHdUfWEOxcqBC.png)
- 优雅的做法
```c
void quick_sort(int q[], int l, int r)//输入数组，最左端（下界），最右端（上界）
{
    if (l >= r) return;//检测数组是否为空
    //将指针i,j初始值设置为数组两端外的位置
    //设置分界点为中间值
    int i = l - 1, j = r + 1, x = q[(l+r+1)/2];

    while (i < j)    //指针不相遇就一直执行
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        //只要指针所指的数满足条件，指针就会一直往中间移动，直到两个指针都停在需要交换的数上
        if (i < j) swap(q[i], q[j]);
    }//经过一轮轮的交换，最终实现一分为二
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //此时i>=j,递归两段时，j为左段的上界，j+1为右段下界
    //因此若用i,则i为右段的下界，i-1为左段的上界，不可同时用i，j，防止i=j的情况出错
}

```
*注意：若分界点用上界或者下界，就有可能出现两个指针都停留在上界或下界的情况，如下图出现无限递归的情况。*![](https://s2.loli.net/2022/03/20/MrsIcPhovFnQqZi.png)

*因此用下界做分界点不能传i和i-1，用上界做分界点不能传j和j+1。*


---

#### 2.归并排序
**步骤**
1. 确定定分界点，选择中点mid=(l+r)/2。
2. 递归排序左右两段（每一段定下分界点然后继续分下去）。
3. 归并，合二为一（将两段排序合并）

++该算法为一个双指针算法，两段各有一个指针++![](https://s2.loli.net/2022/03/21/IYGyP6NB7WLVvXe.png)

时间复杂度：

![](https://s2.loli.net/2022/03/21/ntm5UN3SeCGTKhR.png)

*注：稳定：相同的元素排序后先后位置与原来一样。归并一般是稳定的，快排一般是不稳定的。*

**实现**

```c
void merge_sort(int q[], int l, int r)//输入待排序数组q，下界l，上界r
{
    if (l >= r) return;//若数组为空或只有一个数就return（也是递归到底的情况）

    int mid = l + r >> 1;//设置分割点为中点
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);//对左右两段分别进行递归排序
    //递归之后，接下来数组左右两段分别是有序的
    int k = 0, i = l, j = mid + 1;//k为合并后数组下标，i为左段指针，j为右段指针
    while (i <= mid && j <= r)//直到其中一段循环完毕才脱离循环
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];//依次比较两段数，存入tmp数组（合并）

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];将剩下的全部放入tmp数组

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = //tmp[j];最后将tmp数组复制到q开启下一轮比较
}
```
---
## 二. 二分查找
二分的本质是：一组元素有一种性质，一点的一边满足这个性质，另一边不满足这个性质，二分查找就能找出这个性质的分界点。*因此二分的本质并非单调性，单调性只是让数组拥有了这种性质*。

![](https://s2.loli.net/2022/03/21/8n2bCt5WF7yrIJx.png)
#### 1.整数二分
**步骤**：
1. 找中间值mid
2. 根据题目设置条件，检测mid值是否满足条件，在左段还是右段
3. 改变区间到包含目标的区间，然后继续二分

==*注意：因为二分后有两段，同一条件下，判断mid在左段为真，和判断mid在右段为真是有些许区别的，会出边界问题，如下*==

![](https://s2.loli.net/2022/03/22/VdNo3hUsGe7K4QB.png)

**实现**

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用（mid在右段时为真）
int bsearch_1(int l, int r)//输入下界和上界
{
    while (l < r)//停止的条件是l=r,因此目标值下标就是l或者r
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;     
        //check()判断mid是否满足性质，这里条件决定mid左为真还是右为真，再根据这个判断区间的变化
        else l = mid + 1;//说明目标一定不在原来的左段中，所以+1
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用（mid在左段为真）
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;//说明目标一定不在原来的右段中，所以-1
    }
    return l;
}

```
该模板的一些==细节==：
1. 对于有序数组查找x，其中有多个x，判断条件在左边为真时，即 mid <= x ,最后查找到的是最右边的一个x，而判断条件右边为真时，即 mid >= x ,查找到的是最左边的一个x。  如：12466678中找6 ，方案1查找到的最左边的6，方案2查找的是最右边的6。

    可以理解为判断左段为真，就是优先让l右移逼近x，直到移动到最后一个x；右段为真，就是优先让r左移逼近x，直到最左边一个x。
2. 为什么判断mid左段为真时mid要上界下界先+1再除以2？    因为不加1，在只有两个数字判断右边一个数字时回出现死循环，如下图![](https://s2.loli.net/2022/03/23/REHro5ZgU9BviMA.png)

3.  若查找一个不存在的元素，最后返回的是
4.  一个联想过程记忆![](https://s2.loli.net/2022/03/23/Iig6ACcabzMfUy5.png)


**实现2**

b站找到了一个新的模板，巧妙的规避了一些问题，遂记录一下

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r)//输入上界和下界
{   
    l = l-1; r = N;//将指针移动到数组上下界两端，即-1到n
    while ((l+1)!=r)//停止的条件是l=r,因此目标值下标就是l或者r
    {
        int mid = l + r >> 1;//mid直接上界加下界除以2，不用先+1
        if (check(mid)) l = mid;  
        //check()判断mid是否满足性质，这里条件可以控制取值是啥。
        else r = mid;
    }
    return l;//return r也可以，根据条件不同可以调节
}
```
这里通过将上界下界指针向外移动一位，巧妙的规避了mid要+1的问题。条件及其对应取值如下![](https://s2.loli.net/2022/03/23/D2Q7xk4LtFrsghn.png)
[b站链接](https://www.bilibili.com/video/BV1d54y1q7k7?share_source=copy_web)

**整数二分整体总结**

整数二分的步骤前面已经说清楚了，其中有几个关键点（设要找的数为x，数组为q[n]，中间值下标mid，左指针l，右指针r）
1. 关键的目标值有四个，只有一个x时就是x本身，多个x就有左边界和右边界，这算两个；还有两个是x左边的一个值和x右边的一个值。见下图数轴上的1234.
2. 我们可以把二分后的数组看成三个区域：左段，mid，右段。见下图
3. 要对一个数组不停二分，就得不停循环，while循环结束的条件很重要。
4. 当数组中有偶数个元素时，mid有两种取法，该取哪个很重要。
5. 对中间值q[mid]的判断条件应该用什么。即if（）里中间值怎么和x比较。
6. 二分后的两段，答案在左段还是右段，选择哪一段，要不要包含mid。

其中最核心的是 5.判断条件 和 6.选取区间

![](https://s2.loli.net/2022/03/25/PqErABQ9HiL1CeO.jpg)

下面根据上图解释
1. while的结束条件限定了r和l最后指向哪个位置，先假设最后都指向x的位置（即方案1）
2. 最后的取值是四种里的哪一个，mid加不加1，与判断条件和选取区间的方式有关
3. 判断条件有>=x,>x,<=x,<x四种。这里我们可以用一种==排除==的思想去考虑，比如对<=x来说，如果q[mid]<=x,说明mid左边的数一定<=x,因此x必定在mid处（=x的情况）或者mid的右边，所以我们就排除了左边段，接下来选择区间就应该选择x所在的右边段和mid。再比如>x的情况，如果说q[mid]都大于x了，没有相等的可能，所以mid包括右段都大于x，也就排除了右段和mid，接下来的就应该选择左段了。具体排除了哪一部分见上图。
4. 判断完后的操作也有四种，l = mid; r = mid; l = mid+1; r = mid-1;他们分别表示选择左段还是右段，包不包含mid。这些就根据判断条件来写，每个判断条件的true和false都有一个选区间操作。值得注意的是l控制选右段，r控制选左段，所以==一个判断条件下，必然包含一个带l的条件和一个带r的条件==。
5. 当只有两个元素时，mid可以选第一个或第二，若采用l = mid，mid选左边一个的话还是l，就会出现死循环。同样，当采用r = mid时，选右边一个还是r，也会死循环。==所以l=mid要用mid=l+r+1>>1,mid=r要用mid=l+r>>1==。因此同时在这里用l = mid和r = mid就不行。
6. 结合上面两点，就是图中绿色字体说的==只能有AC和BD两种组合==。
7. 先设定判断条件，再根据排除的部分确定要选取的区间，再根据选择区间的方式确定mid的取值方式就能得出图中八种组合。前文提到的四种值各有两种组合来得到（详细如图）
8. 个人认为只记前四种就好，数轴上1和4的值可以用2和3偏移得到，不用搞的太复杂。

可以看出又要看判断条件，又要看mid取值方法，又要确定取区间的方法，很是麻烦。

我们可以通过改变while循环的结束条件来规避一些问题（方案2）
1. 把while的结束的条件改为l+1=r，即while((l+1)!=r){}，避免了mid取值造成死循环的问题。
2. 把r和l像两端再移动一位，只有一个元素时也能进入循环。
3. r和l最后会处于相邻的两个位置，这两个位置正好横跨x区域和非x区域的交界线（方案2的图）
4. <和>=会取到左交界线，>和<=会取到右交界线；l取交界线左边，r去交界线右边。

## 三. 高精度
#### 1.加法
设两个超长整数A和B相加得C，对应每一位Ai,Bi,Ci，进位为t
1. 因为位数太长，所以先用string输入待运算的数字
2. 将string里的数存入数组中
3. 因为涉及进位，在数组末尾添一个数比较方便，所以逆序存入数组。
4. 然后每一位计算：==Ci = (Ai+Bi+t)%10==    ， 下一位的 ==t' = (Ai+Bi+t)/10==

输入的实现:

```c
vector<int> input(){
    string a;
    cin>>a;
    
    vector<int> A;
    for(int i = a.size();i>=0;i--) A.push_back(a[i]-'0');//逆序输入
    
    return A;
}
```


实现

```c
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);//判断哪个数长

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )//以位数多的数长度为标准
    {
        t += A[i];
        if (i < B.size()) t += B[i];//此时t为Ai+Bi+t
        C.push_back(t % 10);//将本位的和存入c
        t /= 10;//若小于10 t为0，若大于10 t为1
    }

    if (t) C.push_back(t);//单独判断最后一位，若有进位把进位加入下一位
    return C;
}
```
#### 2.减法
超长整数A-B=C，每一位为Ai，Bi，Ci。t为借位和运算中间变量
1.  string里的数存进数组
2.  保证A>B，A<B就算B-A加个负号。先判断长度，长度相等再比较每一位大小。
3.  t先为借位，先Ai-t减掉上一位借位存入t，此时t是这一位的被减数
4.  然后t-Bi存入t，此时t是本位直接相减的结果，可能正，可能负
5.  将 ==(t+10)%10== 存入Ci，如果t为负，则是借位后的结果，t为正就是不用借位
6.  最后判断t的正负，正将t置为0，负将t置为1，作为下一轮Ai要减去的借位
7.  重复以上步骤，最后去掉C的前导0

实现：

```c
vector<int> sub(vector<int> &A,vector<int> &B){
    int t=0;
    vector<int> C;
    for(int i=0;i<A.size();i++){
        t = A[i]-t;
        if(i<b.size()) t-=B[i];
        C.push_back((t+10)%10);
        if(t<0) t = 1;
        else t=0;
    }
    while(C.size()>1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 3.乘法
这里讨论的是一个超长整数和一个短的int型整数的乘法

A为高精度整数，b为int型整数，C为结果，t为进位
1. 和加法差不多，把每一位的加法变成了乘法
2. 只要进位不为0就会循环...||t


```c
vector<int> mul(vector<int> &A,int b){
    vector<int> C;
    int t;
    for(int i=0;i<A.size()||t;i++){ //没遍历完或者进位t不为0都会循环
       if(i<A.size()) t = A[i]*b+t;
        C.push_back(t%10);
        t/=10;
    }
    while(C.size()>1 && C.back() == 0) C.pop_back();
    return C;
}
```
#### 4.除法
和乘法一样，是一个高精度数除以一个低精度数。注意除法从==高位算起==

A为被除数，b为除数，C为结果，r为余数
1. 每一位运算，Ci都是（r*10+Ci）/bi
2. 每一位运算过后的余数是（r*10+Ci）%bi
3. 第一位相当于上一位的余数为0
4. 因为有最后有结果和余数两个值，所以可以返回结果，余数输入引用 
5. 注意去掉前导0


```c
vector<int> div(vector<int> &A,int &b,int &r){
    vector<int> C;
    for(int i=A.size()-1;i>=0;i--){ //逆序读取
        r = r*10 + A[i];
        C.push_back(r/b[i]);
        r%=b[i];
    }
    //最后结果是逆序的，需要处理
    reverse(C.begin(), C.end());//将顺序颠倒过来   
    while(C.size()>1 && C.back() == 0) C.pop_back();
    return C;
}

```
## 四. 前缀和，差分

#### 1.前缀和

##### 一维
- 前缀和：有数组a1，a2，a3，...，an，前缀和就是数组Si = a1+a2+a3+...+ai (下标从1开始,方便公式的统一)
- 如何求Si：见代码，注意S0设置成0，a1也为0，和前缀一致
- 作用：快速求a[l,r]的和，即Sr-S(l-1)

```c
for(int i=1;i<n;i++)//求Si
    s[i] = s[i-1]+ai;//S[0]=0，因此S1也适用此代码
    
a[l] + ... + a[r] = S[r] - S[l - 1]//求a[l,r]的和，时间复杂度为O(1)
```
##### 二维
二维前缀和S[i][j]相当于求a[i][j]左上角矩形范围内的和。有了前缀和S[i]可以很方便的计算出任意矩形范围内的a[i][j]的和。


![](https://s2.loli.net/2022/04/29/3uRne4v6YxtS9rl.png)
如上图：

**求S[i][j]：**
1. 中棕色为整个二维数组a[i][j]；绿色为S[i][j]；红色为待求范围的和，左上角坐标为(x1,y1),右下角为(x2,y2)。
2. 要求S[i][j],先把它分为两部分，a[i][j]和剩下的
3. 出去a[i][j]的部分（把红色看为a[i][j]），就是蓝色框加上绿色框减去多加的左上角小框。
4. 公式： S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]
5. 下标依旧从1开始，也就是说0行0列的值都为0

**求红色部分：**
1. 从图中很容易看出，要计算红色部分，只需要减去可见的绿色部分。
2. 用S[i][j]减去蓝色框和青色框，再加上多减掉的左上角小方框。
3. 公式：红色部分a[i][j]的和为  ==S[x2][y2]-S[x1-1][y2]-S[x2][y1-1]+S[x1-1][y1-1]==
 
#### 2.差分（前缀和的逆运算）

**一维**
- 构造一个数组b,使a是数组b的前缀和，ai=b1+b2+b3+...+bi，b就是a的差分
- 作用：如果让a的[l,r]区间的每个数加上一个c，只需要在bl上加c，这样从b算出的a中，al及其后面的元素都会多加一个c。为了让r之后的数不加c，只需要让br-c。只用改两个数，时间复杂度为O(1)
- 可以假定a中每个元素为0，因此b中也全为0。让ai等于多少，就等同于在[i,i]这个区间上加上这个数。因此差分就不需要构造，只需要考虑上面的一个操作——b[l]+c和b[r+1]-c

实现：

```c++
int a[N];
int b[N];
int n,m;//n为前缀和a的长度
insert(int l,int r,int c ){ //插入操作
    b[l]+=c;
    b[r+1]-=c;
}
for(int i=1;i<=n;i++) insert(i,i,a[i]);//此处把b变成了a的差分
//相当于把b开始全是0，每一位都插入a对应的元素，所以b的前缀和为a

```
**二维**

- 给原矩阵a[i,j]构造一个差分矩阵b[i,j]
- 插入：给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c
- 同样也可以假设b全是0，然后全部插入一遍a的每个值就可以得到b

实现：

```c
int a[N][N];
int b[N][N];
insert(int x1,int y1,int x2,int y2,int c){
    b[x1, y1] += c;
    b[x2 + 1, y1] -= c;//减去多余的c
    b[x1, y2 + 1] -= c;
    b[x2 + 1, y2 + 1] += c;
}
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        insert(i,j,i,j,a[i][j]);//此处b变为了a的差分


```

**差分的优势**：当有多个让数组的一部分+c的操作时，可以在差分上多次插入，这样每次操作的时间复杂度为O(1)。只有首尾的求差分和求前缀和的操作为O(n)。

## 五.双指针算法
如下图，有两种双指针算法：
- 图一，两个指针分别指向两个区间，比如归并排序算法
- 图二，两个指针指向一个区间，比如二分算法
![](https://s2.loli.net/2022/04/30/BjTAvStd5gRu7Ws.png)

**核心**：朴素的双重循环的时间复杂度为O(n^2)，而双指针算法可以用条件将其优化为O(n)，优化==双重循环==

实现：

```c
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;//此处的check条件可以大大减少时间复杂度

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```
## 六.位运算
**求n的二进制表示的第k位是（第几位从0算起）？**
1. 将n向右移k位。
2. 看看个位是几，就是&1
实现：

```c
 n >> k & 1
```
**返回n的二进制表示的最后一个1（lowbit算法）**
- 让n&(-n)，即让n&(~n+1)
![](https://s2.loli.net/2022/04/30/BCakWz6smyexpNu.png)

实现：

```c
lowbit(n) = n & -n
```
应用：可以不停的减去最后一个1，同时计数，这样可以得到有多少个1

## 七.离散化
将无限空间中的有限个体映射到有限的空间中去，比如将10^5个数，每个数的值域很大(0~10^9),映射到a[]:0,1,2,3,4,5...

注意点：
- a[]中可能有重复的值，需要去重
- 如何算出数x离散化后的值，即下标（使用二分）





