# 第一章：基础算法

## 一. 排序
#### 1.快速排序
**步骤**（对数组q[]）
1. 确定分界点：q[l],q[(l+r)/2],q[r]。最大最小中间值随机都可。
2. 调整区间：若分界点为x，将小于x的放在左边，大于x的放在右边（反过来同理，主要是一分为二）。
3. 递归处理左右两段。

**实现**
- 一种简单的方法：利用多余的空间![](https://s2.loli.net/2022/03/20/MVKHdUfWEOxcqBC.png)
- 优雅的做法
```c
void quick_sort(int q[], int l, int r)//输入数组，最左端（下界），最右端（上界）
{
    if (l >= r) return;//检测数组是否为空
    //将指针i,j初始值设置为数组两端外的位置
    //设置分界点为中间值
    int i = l - 1, j = r + 1, x = q[(l+r+1)/2];

    while (i < j)    //指针不相遇就一直执行
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        //只要指针所指的数满足条件，指针就会一直往中间移动，直到两个指针都停在需要交换的数上
        if (i < j) swap(q[i], q[j]);
    }//经过一轮轮的交换，最终实现一分为二
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //此时i>=j,递归两段时，j为左段的上界，j+1为右段下界
    //因此若用i,则i为右段的下界，i-1为左段的上界，不可同时用i，j，防止i=j的情况出错
}

```
*注意：若分界点用上界或者下界，就有可能出现两个指针都停留在上界或下界的情况，如下图出现无限递归的情况。*![](https://s2.loli.net/2022/03/20/MrsIcPhovFnQqZi.png)

*因此用下界做分界点不能传i和i-1，用上界做分界点不能传j和j+1。*


---

#### 2.归并排序
**步骤**
1. 确定定分界点，选择中点mid=(l+r)/2。
2. 递归排序左右两段（每一段定下分界点然后继续分下去）。
3. 归并，合二为一（将两段排序合并）

++该算法为一个双指针算法，两段各有一个指针++![](https://s2.loli.net/2022/03/21/IYGyP6NB7WLVvXe.png)

时间复杂度：

![](https://s2.loli.net/2022/03/21/ntm5UN3SeCGTKhR.png)

*注：稳定：相同的元素排序后先后位置与原来一样。归并一般是稳定的，快排一般是不稳定的。*

**实现**

```c
void merge_sort(int q[], int l, int r)//输入待排序数组q，下界l，上界r
{
    if (l >= r) return;//若数组为空或只有一个数就return（也是递归到底的情况）

    int mid = l + r >> 1;//设置分割点为中点
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);//对左右两段分别进行递归排序
    //递归之后，接下来数组左右两段分别是有序的
    int k = 0, i = l, j = mid + 1;//k为合并后数组下标，i为左段指针，j为右段指针
    while (i <= mid && j <= r)//直到其中一段循环完毕才脱离循环
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];//依次比较两段数，存入tmp数组（合并）

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];将剩下的全部放入tmp数组

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = //tmp[j];最后将tmp数组复制到q开启下一轮比较
}
```
---
## 二. 二分查找
二分的本质是：一组元素有一种性质，一点的一边满足这个性质，另一边不满足这个性质，二分查找就能找出这个性质的分界点。*因此二分的本质并非单调性，单调性只是让数组拥有了这种性质*。

![](https://s2.loli.net/2022/03/21/8n2bCt5WF7yrIJx.png)
#### 1.整数二分
**步骤**：
1. 找中间值mid
2. 根据题目设置条件，检测mid值是否满足条件，在左段还是右段
3. 改变区间到包含目标的区间，然后继续二分

==*注意：因为二分后有两段，同一条件下，判断mid在左段为真，和判断mid在右段为真是有些许区别的，会出边界问题，如下*==

![](https://s2.loli.net/2022/03/22/VdNo3hUsGe7K4QB.png)

**实现**

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用（mid在右段时为真）
int bsearch_1(int l, int r)//输入下界和上界
{
    while (l < r)//停止的条件是l=r,因此目标值下标就是l或者r
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;     
        //check()判断mid是否满足性质，这里条件决定mid左为真还是右为真，再根据这个判断区间的变化
        else l = mid + 1;//说明目标一定不在原来的左段中，所以+1
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用（mid在左段为真）
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;//说明目标一定不在原来的右段中，所以-1
    }
    return l;
}

```
该模板的一些==细节==：
1. 对于有序数组查找x，其中有多个x，判断条件在左边为真时，即 mid <= x ,最后查找到的是最右边的一个x，而判断条件右边为真时，即 mid >= x ,查找到的是最左边的一个x。  如：12466678中找6 ，方案1查找到的最左边的6，方案2查找的是最右边的6。

    可以理解为判断左段为真，就是优先让l右移逼近x，直到移动到最后一个x；右段为真，就是优先让r左移逼近x，直到最左边一个x。
2. 为什么判断mid左段为真时mid要上界下界先+1再除以2？    因为不加1，在只有两个数字判断右边一个数字时回出现死循环，如下图![](https://s2.loli.net/2022/03/23/REHro5ZgU9BviMA.png)

3.  若查找一个不存在的元素，最后返回的是
4.  一个联想过程记忆![](https://s2.loli.net/2022/03/23/Iig6ACcabzMfUy5.png)


**实现2**

b站找到了一个新的模板，巧妙的规避了一些问题，遂记录一下

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r)//输入上界和下界
{   
    l = l-1; r = N;//将指针移动到数组上下界两端，即-1到n
    while ((l+1)!=r)//停止的条件是l=r,因此目标值下标就是l或者r
    {
        int mid = l + r >> 1;//mid直接上界加下界除以2，不用先+1
        if (check(mid)) l = mid;  
        //check()判断mid是否满足性质，这里条件可以控制取值是啥。
        else r = mid;
    }
    return l;//return r也可以，根据条件不同可以调节
}
```
这里通过将上界下界指针向外移动一位，巧妙的规避了mid要+1的问题。条件及其对应取值如下![](https://s2.loli.net/2022/03/23/D2Q7xk4LtFrsghn.png)
[b站链接](https://www.bilibili.com/video/BV1d54y1q7k7?share_source=copy_web)

**整数二分整体总结**

整数二分的步骤前面已经说清楚了，其中有几个关键点（设要找的数为x，数组为q[n]，中间值下标mid，左指针l，右指针r）
1. 关键的目标值有四个，只有一个x时就是x本身，多个x就有左边界和右边界，这算两个；还有两个是x左边的一个值和x右边的一个值。见下图数轴上的1234.
2. 我们可以把二分后的数组看成三个区域：左段，mid，右段。见下图
3. 要对一个数组不停二分，就得不停循环，while循环结束的条件很重要。
4. 当数组中有偶数个元素时，mid有两种取法，该取哪个很重要。
5. 对中间值q[mid]的判断条件应该用什么。即if（）里中间值怎么和x比较。
6. 二分后的两段，答案在左段还是右段，选择哪一段，要不要包含mid。

其中最核心的是 5.判断条件 和 6.选取区间

![](https://s2.loli.net/2022/03/25/PqErABQ9HiL1CeO.jpg)

下面根据上图解释
1. while的结束条件限定了r和l最后指向哪个位置，先假设最后都指向x的位置（即方案1）
2. 最后的取值是四种里的哪一个，mid加不加1，与判断条件和选取区间的方式有关
3. 判断条件有>=x,>x,<=x,<x四种。这里我们可以用一种==排除==的思想去考虑，比如对<=x来说，如果q[mid]<=x,说明mid左边的数一定<=x,因此x必定在mid处（=x的情况）或者mid的右边，所以我们就排除了左边段，接下来选择区间就应该选择x所在的右边段和mid。再比如>x的情况，如果说q[mid]都大于x了，没有相等的可能，所以mid包括右段都大于x，也就排除了右段和mid，接下来的就应该选择左段了。具体排除了哪一部分见上图。
4. 判断完后的操作也有四种，l = mid; r = mid; l = mid+1; r = mid-1;他们分别表示选择左段还是右段，包不包含mid。这些就根据判断条件来写，每个判断条件的true和false都有一个选区间操作。值得注意的是l控制选右段，r控制选左段，所以==一个判断条件下，必然包含一个带l的条件和一个带r的条件==。
5. 当只有两个元素时，mid可以选第一个或第二，若采用l = mid，mid选左边一个的话还是l，就会出现死循环。同样，当采用r = mid时，选右边一个还是r，也会死循环。==所以l=mid要用mid=l+r+1>>1,mid=r要用mid=l+r>>1==。因此同时在这里用l = mid和r = mid就不行。
6. 结合上面两点，就是图中绿色字体说的==只能有AC和BD两种组合==。
7. 先设定判断条件，再根据排除的部分确定要选取的区间，再根据选择区间的方式确定mid的取值方式就能得出图中八种组合。前文提到的四种值各有两种组合来得到（详细如图）
8. 个人认为只记前四种就好，数轴上1和4的值可以用2和3偏移得到，不用搞的太复杂。

可以看出又要看判断条件，又要看mid取值方法，又要确定取区间的方法，很是麻烦。

我们可以通过改变while循环的结束条件来规避一些问题（方案2）
1. 把while的结束的条件改为l+1=r，即while((l+1)!=r){}，避免了mid取值造成死循环的问题。
2. 把r和l像两端再移动一位，只有一个元素时也能进入循环。
3. r和l最后会处于相邻的两个位置，这两个位置正好横跨x区域和非x区域的交界线（方案2的图）
4. <和>=会取到左交界线，>和<=会取到右交界线；l取交界线左边，r去交界线右边。

## 三. 高精度
#### 1.加法
设两个超长整数A和B相加得C，对应每一位Ai,Bi,Ci，进位为t
1. 因为位数太长，所以先用string输入待运算的数字
2. 将string里的数存入数组中
3. 因为涉及进位，在数组末尾添一个数比较方便，所以逆序存入数组。
4. 然后每一位计算：Ci = (Ai+Bi+t)%10    ， 下一位的 t' = (Ai+Bi+t)/10

实现

```c
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);//判断哪个数长

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )//以位数多的数长度为标准
    {
        t += A[i];
        if (i < B.size()) t += B[i];//此时t为Ai+Bi+t
        C.push_back(t % 10);//将本位的和存入c
        t /= 10;//若小于10 t为0，若大于10 t为1
    }

    if (t) C.push_back(t);//单独判断最后一位，若有进位把进位加入下一位
    return C;
}
```
